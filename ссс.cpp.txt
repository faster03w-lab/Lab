#include <iostream>
#include <cstdlib>
#include <cstring> // для memmove, если понадобится (но в данном случае не используется)

using namespace std;

// Функция для поиска индексов строк, состоящих полностью из нулей
int* findRowsWithZero(int** matrix, int rows, int cols, int* count) {
    int* temp = (int*)malloc(rows * sizeof(int));
    *count = 0;
    for (int i = 0; i < rows; i++) {
        bool allZeros = true;
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] != 0) {
                allZeros = false;
                break;
            }
        }
        if (allZeros) {
            temp[(*count)++] = i;
        }
    }
    return temp;
}

int main() {
    setlocale(LC_ALL, "Russian");

    // Создаём начальную матрицу 2x2
    int** initialMatrix = (int**)malloc(2 * sizeof(int*));
    for (int i = 0; i < 2; i++) {
        initialMatrix[i] = (int*)malloc(2 * sizeof(int));
    }

    // Заполняем начальную матрицу
    cout << "Введите элементы матрицы 2x2:" << endl;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            cout << "Элемент [" << i << "][" << j << "]: ";
            cin >> initialMatrix[i][j];
        }
    }

    // Извлекаем A, B, C, D
    int A = initialMatrix[0][0];
    int B = initialMatrix[0][1];
    int C = initialMatrix[1][0];
    int D = initialMatrix[1][1];

    // Проверка: A и B не должны быть отрицательными
    while (A < 0 || B < 0) {
        cout << "Ошибка: A и B не могут быть отрицательными. Введите новые значения:" << endl;
        cout << "A: ";
        cin >> A;
        cout << "B: ";
        cin >> B;
        // Обновляем в initialMatrix (опционально, но логично)
        initialMatrix[0][0] = A;
        initialMatrix[0][1] = B;
    }

    // Освобождаем память начальной матрицы (после извлечения A,B,C,D)
    for (int i = 0; i < 2; i++) {
        free(initialMatrix[i]);
    }
    free(initialMatrix);

    // Создаём расширенную матрицу размером (2 + A) x (2 + B)
    int rows = 2 + A;
    int cols = 2 + B;

    int** matrix = (int**)calloc(rows, sizeof(int*));
    for (int i = 0; i < rows; i++) {
        matrix[i] = (int*)calloc(cols, sizeof(int));
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i * C + j * D;
        }
    }

    cout << "Расширенная матрица:" << endl;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }

    // Находим строки, полностью состоящие из нулей
    int deleteCount = 0;
    int* rowsToDelete = findRowsWithZero(matrix, rows, cols, &deleteCount);

    if (deleteCount > 0) {
        // Сдвигаем ненулевые строки в начало
        int writeIndex = 0;
        for (int readIndex = 0; readIndex < rows; readIndex++) {
            bool shouldDelete = false;
            for (int k = 0; k < deleteCount; k++) {
                if (rowsToDelete[k] == readIndex) {
                    shouldDelete = true;
                    break;
                }
            }
            if (!shouldDelete) {
                if (writeIndex != readIndex) {
                    // Перемещаем указатель строки
                    free(matrix[writeIndex]); // освобождаем целевую строку, если она была
                    matrix[writeIndex] = matrix[readIndex];
                    matrix[readIndex] = nullptr; // избегаем двойного освобождения
                }
                writeIndex++;
            } else {
                // Освобождаем память удаляемой строки
                free(matrix[readIndex]);
                matrix[readIndex] = nullptr;
            }
        }

        // Теперь уменьшаем количество строк с помощью realloc
        int newRows = rows - deleteCount;
        int** newMatrixPtr = (int**)realloc(matrix, newRows * sizeof(int*));
        if (newMatrixPtr != nullptr) {
            matrix = newMatrixPtr;
            rows = newRows;
        } else {
            // Обработка ошибки realloc (маловероятно, но желательно)
            cerr << "Ошибка при realloc!" << endl;
            // Можно продолжить работать с matrix как есть, но rows не обновляем
        }
    }

    // Выводим итоговую матрицу
    cout << "Матрица после удаления строк с нулями:" << endl;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }

    // Освобождение памяти (в конце программы — допустимо)
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
    }
    free(matrix);
    free(rowsToDelete);

    return 0;
}